diff --git a/include/utility/handler.h b/include/utility/handler.h
index 11b0f04..446f8fe 100644
--- a/include/utility/handler.h
+++ b/include/utility/handler.h
@@ -7,7 +7,12 @@
 
 __BEGIN_UTIL
 
-typedef void (Handler)();
+class Handler
+{
+public:
+    Handler() {}
+    virtual void operator()() = 0;
+};
 
 __END_UTIL
 
diff --git a/src/abstraction/alarm.cc b/src/abstraction/alarm.cc
index ec8b9ce..86c311e 100644
--- a/src/abstraction/alarm.cc
+++ b/src/abstraction/alarm.cc
@@ -1,8 +1,9 @@
 // EPOS Alarm Abstraction Implementation
 
-#include <semaphore.h>
 #include <alarm.h>
 #include <display.h>
+#include <thread.h>
+#include <utility/list.h>
 
 __BEGIN_SYS
 
@@ -43,25 +44,36 @@ Alarm::~Alarm()
 }
 
 
+class SuspendHandler : public Handler
+{
+public:
+    SuspendHandler(Thread * thread) : _thread(thread) {}
+    void operator()() { _thread->resume(); }
+
+private:
+    Thread * _thread;
+};
+
+
 // Class methods
 void Alarm::delay(const Microsecond & time)
 {
     db<Alarm>(TRC) << "Alarm::delay(time=" << time << ")" << endl;
 
-    Tick t = _elapsed + ticks(time);
-
-    while(_elapsed < t);
+    Thread * self = Thread::self();
+    SuspendHandler sh(self);
+    Alarm alarm(time, &sh, 1);
+    self->suspend();
 }
 
 
 void Alarm::handler(const IC::Interrupt_Id & i)
 {
-    static Tick next_tick;
-    static Handler * next_handler;
+    typedef Simple_List<Handler> HList;
 
     lock();
 
-    _elapsed++;
+    ++_elapsed;
 
     if(Traits<Alarm>::visible) {
         Display display;
@@ -72,23 +84,18 @@ void Alarm::handler(const IC::Interrupt_Id & i)
         display.position(lin, col);
     }
 
-    if(next_tick)
-        next_tick--;
-    if(!next_tick) {
-        if(next_handler) {
-            db<Alarm>(TRC) << "Alarm::handler(h=" << reinterpret_cast<void *>(next_handler) << ")" << endl;
-            (*next_handler)();
-        }
-        if(_request.empty())
-            next_handler = 0;
-        else {
-            Queue::Element * e = _request.remove();
-            Alarm * alarm = e->object();
-            next_tick = alarm->_ticks;
-            next_handler = alarm->_handler;
-            if(alarm->_times != -1)
-                alarm->_times--;
-            if(alarm->_times) {
+    HList handler;
+
+    if(!_request.empty()) {
+        _request.head()->promote();
+        while(_request.head()->rank() <= 0) {
+            Queue::Element* e = _request.remove();
+            Alarm* alarm = e->object();
+
+            handler.insert(new (kmalloc(sizeof(HList::Element))) HList::Element(alarm->_handler));
+            
+            alarm->_times--;
+            if(alarm->_times > 0) {
                 e->rank(alarm->_ticks);
                 _request.insert(e);
             }
@@ -96,6 +103,11 @@ void Alarm::handler(const IC::Interrupt_Id & i)
     }
 
     unlock();
+
+    for (HList::Iterator it = handler.begin(); it != handler.end(); ++it) {
+        Handler * h = it->object();
+        (*h)();
+    }
 }
