Index: include/application.h
===================================================================
--- include/application.h	(revision 3687)
+++ include/application.h	(working copy)
@@ -4,6 +4,7 @@
 #define __application_h
 
 #include <utility/heap.h>
+#include <segment.h>
 
 extern "C"
 {
@@ -18,17 +19,34 @@
     friend class Init_Application;
     friend void * ::malloc(size_t);
     friend void ::free(void *);
+    friend void * ::operator new(size_t, const Uncached_Alloc&);
+    friend void * ::operator new[](size_t, const Uncached_Alloc&);
 
 private:
     static void init();
 
 private:
-    static char _preheap[sizeof(Heap)];
+    // allocate space for both cached and uncached heap
+    static char _preheap[sizeof(Segment) + sizeof(Heap)];
+    static Segment * _heap_segment;
     static Heap * _heap;
+
+    // uncached heap shit
+    static char _preuncached[sizeof(Segment) + sizeof(Heap)];
+    static Segment * _uncached_segment;
+    static Heap * _uncached;
 };
 
 __END_SYS
 
+inline void * operator new(size_t bytes, const Uncached_Alloc&) {
+    return _SYS::Application::_uncached->alloc(bytes);
+}
+
+inline void * operator new[](size_t bytes, const Uncached_Alloc&) {
+    return _SYS::Application::_uncached->alloc(bytes);
+}
+
 #include <utility/malloc.h>
 
 #endif
Index: include/system/types.h
===================================================================
--- include/system/types.h	(revision 3687)
+++ include/system/types.h	(working copy)
@@ -12,9 +12,18 @@
     void free(void *);
 }
 
+enum Kernel_Alloc { KERNEL };
+enum Uncached_Alloc { UNCACHED };
+
 inline void * operator new(size_t s, void * a) { return a; }
 inline void * operator new[](size_t s, void * a) { return a; }
 
+void * operator new(size_t s, const Kernel_Alloc&);
+void * operator new[](size_t s, const Kernel_Alloc&);
+
+void * operator new(size_t s, const Uncached_Alloc&);
+void * operator new[](size_t s, const Uncached_Alloc&);
+
 // Utilities
 __BEGIN_UTIL
 class Dummy;
Index: include/system.h
===================================================================
--- include/system.h	(revision 3687)
+++ include/system.h	(working copy)
@@ -11,8 +11,8 @@
 {
     friend class Init_System;
     friend class Init_Application;
-    friend void * kmalloc(size_t);
-    friend void kfree(void *);
+    friend void * ::operator new(size_t bytes, const Kernel_Alloc&);
+    friend void * ::operator new[](size_t bytes, const Kernel_Alloc&);
 
 public:
     static System_Info<Machine> * const info() { assert(_si); return _si; }
@@ -28,4 +28,18 @@
 
 __END_SYS
 
+inline void * operator new(size_t bytes, const Kernel_Alloc&) {
+    __USING_SYS
+    void * addr = System::_heap->alloc(bytes);
+    db<System>(INF) << "System::operator new(bytes=" << bytes << ") => " << addr << endl;
+    return addr;
+}
+
+inline void * operator new[](size_t bytes, const Kernel_Alloc&) {
+    __USING_SYS
+    void * addr = System::_heap->alloc(bytes);
+    db<System>(INF) << "System::operator new[](bytes=" << bytes << ") => " << addr << endl;
+    return addr;
+}
+
 #endif
Index: src/abstraction/alarm_init.cc
===================================================================
--- src/abstraction/alarm_init.cc	(revision 3687)
+++ src/abstraction/alarm_init.cc	(working copy)
@@ -1,7 +1,7 @@
 // EPOS Alarm Abstraction Initialization
 
-#include <system/kmalloc.h>
 #include <alarm.h>
+#include <system.h>
 
 __BEGIN_SYS
 
@@ -9,7 +9,7 @@
 {
     db<Init, Alarm>(TRC) << "Alarm::init()" << endl;
 
-    _timer = new (kmalloc(sizeof(Alarm_Timer))) Alarm_Timer(handler);
+    _timer = new (KERNEL) Alarm_Timer(handler);
 }
 
 __END_SYS
Index: src/abstraction/thread.cc
===================================================================
--- src/abstraction/thread.cc	(revision 3687)
+++ src/abstraction/thread.cc	(working copy)
@@ -1,8 +1,8 @@
 // EPOS Thread Abstraction Implementation
 
-#include <system/kmalloc.h>
 #include <machine.h>
 #include <thread.h>
+#include <system.h>
 
 // This_Thread class attributes
 __BEGIN_UTIL
@@ -23,7 +24,9 @@
 {
     lock();
 
     _thread_count++;

-    _stack = reinterpret_cast<char *>(kmalloc(stack_size));
+    _stack = new (KERNEL) char[stack_size];
 }
 
 
@@ -96,1 +96,1 @@

     unlock();
 
-    kfree(_stack);
+    delete _stack;
 }
 
 
Index: src/abstraction/thread_init.cc
===================================================================
--- src/abstraction/thread_init.cc	(revision 3687)
+++ src/abstraction/thread_init.cc	(working copy)
@@ -1,6 +1,5 @@
 // EPOS Thread Abstraction Initialization
 
-#include <system/kmalloc.h>
 #include <system.h>
 #include <thread.h>
 #include <alarm.h>
@@ -16,7 +15,7 @@
     // MAIN is created first and dispatch won't replace it nor by itself
     // neither by IDLE (which has a lower priority)
     if(preemptive)
-        _timer = new (kmalloc(sizeof(Scheduler_Timer))) Scheduler_Timer(QUANTUM, time_slicer);
+        _timer = new (KERNEL) Scheduler_Timer(QUANTUM, time_slicer);
 }
 
 __END_SYS
Index: src/init/init_application.cc
===================================================================
--- src/init/init_application.cc	(revision 3687)
+++ src/init/init_application.cc	(working copy)
@@ -4,6 +4,7 @@
 #include <mmu.h>
 #include <machine.h>
 #include <application.h>
+#include <address_space.h>
 
 __BEGIN_SYS
 
@@ -18,8 +19,16 @@
 
 	// Initialize Application's heap
 	db<Init>(INF) << "Initializing application's heap" << endl;
-	Application::_heap = new (&Application::_preheap[0]) Heap(MMU::alloc(MMU::pages(HEAP_SIZE)), HEAP_SIZE);
 
+    // cached
+    Application::_heap_segment = new (&Application::_preheap[0]) Segment(HEAP_SIZE);
+	Application::_heap = new (&Application::_preheap[sizeof(Segment)]) Heap(Address_Space(MMU::current()).attach(Application::_heap_segment), Application::_heap_segment->size());
+
+    // uncached
+    typedef Segment::Flags Flags;
+    Application::_uncached_segment = new (&Application::_preuncached[0]) Segment(HEAP_SIZE, Flags::APP | Flags::CD);
+	Application::_uncached = new (&Application::_preuncached[sizeof(Segment)]) Heap(Address_Space(MMU::current()).attach(Application::_uncached_segment), Application::_uncached_segment->size());
+
 	db<Init>(INF) << "done!" << endl;
     }
 };
Index: src/init/init_first.cc
===================================================================
--- src/init/init_first.cc	(revision 3687)
+++ src/init/init_first.cc	(working copy)
@@ -1,7 +1,7 @@
 // EPOS First Thread Initializer
 
 #include <utility/heap.h>
-#include <system/kmalloc.h>
+#include <system.h>
 #include <thread.h>
 
 extern "C" { void __epos_app_entry(); }
@@ -28,8 +28,11 @@
         // If EPOS is not a kernel, then adjust the application entry point to __epos_app_entry,
         // which will directly call main(). In this case, _init will have already been called,
         // before Init_Application, to construct main()'s global objects.
-        Thread::_running = new (kmalloc(sizeof(Thread))) Thread(Thread::Configuration(Thread::RUNNING, Thread::NORMAL), reinterpret_cast<int (*)()>(__epos_app_entry));
+        Thread::_running = new (KERNEL) Thread(Thread::Configuration(Thread::RUNNING, Thread::MAIN), reinterpret_cast<int (*)()>(__epos_app_entry));
 
+        // Idle thread creation must succeed main, thus avoiding implicit rescheduling
+        new (KERNEL) Thread(Thread::Configuration(Thread::READY, Thread::IDLE), &Thread::idle);
+
         db<Init>(INF) << "done!" << endl;
 
         db<Init>(INF) << "INIT ends here!" << endl;
Index: src/system/application_scaffold.cc
===================================================================
--- src/system/application_scaffold.cc	(revision 3687)
+++ src/system/application_scaffold.cc	(working copy)
@@ -7,7 +7,11 @@
 
 // Application class attributes
 char Application::_preheap[];
+Segment * Application::_heap_segment;
 Heap * Application::_heap;
+char Application::_preuncached[];
+Segment * Application::_uncached_segment;
+Heap * Application::_uncached;
 
 __END_SYS
 
